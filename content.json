[{"title":"神奇的1986年5月4日","date":"2017-03-03T11:26:17.000Z","path":"2017/03/03/神奇的1986年5月4日/","text":"昨天分了个crash, 看了崩溃信息是exception &#39;NSInternalInconsistencyException&#39;, reason: &#39;Invalid parameter not satisfying: date&#39;是给UIDatePicker设置日期的时候发生了crash, 如下图: 初步分析是userDate为nil导致的crash, 但是不知道为什么userDate会为空, 看了数据发现只有某些用户才会发生crash, 而且是连续的发生(设置生日的时候crash, 过几分钟打开APP再设置生日, 再crash…), 怀疑是不是服务器把这些用户的生日存错了, 导致返回的日期格式不对(后台:这锅我们不背) 今天找后台查了发生crash的用户的生日格式, 发现格式没问题, 但是, 发生有一个crash的用户的生日是1986-05-04, 于是发现…… 大概意思是说1986年5月4日没有对应的Date(没有这一天?) 看了夏令时相关资料, 我国从1986年5月4日开始实行夏令时, 在这一天会把时间调快1小时, 到9月的某一天再调回来, 因此并不是说没有1986年5月4日这一天, 而应该是这一天少了一个小时, 写段代码验证下: 果然, 是因为Asia/Shanghai这个地方的1986年5月4日这一天0点-1点这段时间没了(没有对应的GMT时间) 根据夏令时的说法: 实施夏令时的时间为:1986年5月4日至9月14日（1986年因是实行夏令时的第一年，从5月4日开始到9月14日结束）1987年4月12日至9月13日1988年4月10日至9月11日1989年4月16日至9月17日1990年4月15日至9月16日1991年4月14日至9月15日 所以以上夏令时开始时间都少了一小时(0点-1点) 解决办法:更改dateFormatter的timeZone, 在中国默认是Asia/Shanghai, 把时区修改为GMT+0800就好了代码: 123456789NSDateFormatter *dateFormatter = [[NSDateFormatter alloc]init];/*设置时区为GMT+0800, 在中国默认为Asia/Shanghai*/[dateFormatter setTimeZone:[NSTimeZone timeZoneWithName:@\"GMT+0800\"]];[dateFormatter setDateFormat:@\"yyyy-MM-dd\"];NSDate *userDate = [dateFormatter dateFromString:[SAKUserService sharedUserService].userExInfo.birthdayString];if (!userDate) &#123; userDate = [NSDate date];&#125;[self.datePicker setDate:userDate]; 总结: 以后使用NSDateFormatter的时候最好设置timeZone为GMT+x时区, 不要使用默认所在国家的timeZone, 也有其他国家也使用(过)夏令时","tags":[{"name":"NSDateFormatter","slug":"NSDateFormatter","permalink":"http://fangli.me/tags/NSDateFormatter/"},{"name":"UIDatePicker","slug":"UIDatePicker","permalink":"http://fangli.me/tags/UIDatePicker/"},{"name":"crash","slug":"crash","permalink":"http://fangli.me/tags/crash/"}]},{"title":"如何创建私有Pod","date":"2017-02-16T13:14:52.000Z","path":"2017/02/16/创建私有Pod/","text":"创建Pod之前应该先了解cocoapods是如何去找到这个Pod的 安装完cocoapods之后会生成一个文件夹~/.cocoapods/repos/, 每次执行pod search [podname]或者pod install之后默认都会去~/.cocoapods/repos/目录及其子目录下寻找名为[podname]的文件夹, 找到对应的版本号, 根据该版本的.podspec去下载相应的代码, 然后集成到项目中 如果在Podfile中指定repos的路径(可以是本地的也可以是远程的), 则在pod install之后会去相应的git仓库寻找.podspec 因此创建一个私有Pod的步骤分为创建repos和创建pod 创建repos创建一个git仓库, 可以在本地, 也可以用Github等, 因为是私有库, 所以这里只是在本地创建. 123mkdir MyTestRepocd MyTestRepogit init 复制MyTestRepo路径, 可以在MyTestRepo目录里面执行pwd, 然后把完整路径复制出来 把MyTestRepo添加到cocoapod的repos中 1pod repo add MyTestRepo [git仓库文件路径] 之后可以在 ~/.cocoapod/repos里面看到有一个名为MyTestRepo的文件夹 以后创建的Pod就是提交到这个仓库里面 创建PodStep1可以使用pod lib create [podName]命令来创建一个Pod, 创建完后的目录结构如下 其中Example文件夹为Demo工程, 里面引用了MyTestPod目录下的MyTestPod, 打开MyTestPod.xcworkspace, 在pods里面能看到Development Pods文件夹, 开始的时候的修改都是在这个文件夹里面 MyTestPod.podspec文件为对这个pod的描述, 往Repos提交Pod的时候, 就是把这个文件提交到MyTestRepo中 Step2修改MyTestPod.podspec文件, 这是一个Ruby文件, 如果把环境改为Ruby则会显示高亮, 各字段的含义如下 123456789101112131415161718192021222324252627282930313233343536373839Pod::Spec.new do |s| # pod的名字 s.name = &apos;MyTestPod&apos; # 版本 s.version = &apos;0.0.1&apos; # 简短的描述 s.summary = &apos;A short description&apos; # 完整的描述, 不能比s.summary短 s.description = &lt;&lt;-DESC A longlong description DESC s.homepage = &apos;https://xxx.com/MyTestPod&apos; s.license = &#123; :type =&gt; &apos;MIT&apos;, :file =&gt; &apos;LICENSE&apos; &#125; s.author = &#123; &apos;方立&apos; =&gt; &apos;fangli02@meituan.com&apos; &#125; # 源代码路径, 执行pod install的时候会根据这个路径去下载代码, 可以是git, ssh, http等 s.source = &#123; :git =&gt; &apos;/Users/fangli/iOSProject/MyTestPod&apos;, :tag =&gt; s.version.to_s &#125; s.ios.deployment_target = &apos;8.0&apos; # 源代码文件, 这里表示MyTestPod/Classes/ 下及其子目录的所有文件 s.source_files = &apos;MyTestPod/Classes/**/*&apos; # 资源文件 # s.resource_bundles = &#123; # &apos;MyTestPod&apos; =&gt; [&apos;MyTestPod/Assets/*.png&apos;] # &#125; # 公开的头文件, 如果不写这个则默认所有都是公开, 否则只公开写的头文件, 非公开的头文件不能被导入 # s.public_header_files = &apos;Pod/Classes/**/*.h&apos; # 依赖的frameworks # s.frameworks = &apos;UIKit&apos;, &apos;MapKit&apos; # 依赖的其他pod # s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos;end Step3在当前目录下执行pod lib lint验证是否通过 当显示MyTestPod passed validation.时则表示验证通过, 否则根据提示的内容对MyTestPod.podspec进行修改 Step4提交当前变动, 并给当前git打上tag 123git add .git commit -m \"init\"git tag \"0.0.1\" Step5把当前pod提交到MyTestRepo中, 在终端中执行 pod repo push MyTestRepo MyTestPod.podspec 执行成功会出现如下文件夹 之后执行pod search MyTestPod就能在本地搜到了 使用自己创建的pod打开新建一个项目, 创建Podfile, 在第一行加入 source &#39;/Users/fangli/.cocoapods/repos/MyTestRepo&#39; 引入自己的podpod &#39;MyTestPod&#39; 之后执行pod install就会根据MyTestRepo里面的描述文件去下载pod的代码, 然后集成到项目里面","tags":[{"name":"pod","slug":"pod","permalink":"http://fangli.me/tags/pod/"}]},{"title":"安装配置ZSH","date":"2016-10-18T06:33:09.000Z","path":"2016/10/18/安装配置ZSH/","text":"在Linux/Unix/Mac下面终端是神器, 默认使用的是bash, 还有另外一个zsh比bash好用, 当然得配合一些插件和模板: oh-my-zsh 安装zsh Ubuntu 1sudo apt-get install zsh CentOS 1yum install zsh 将bash切换为zsh1chsh -s /bin/zsh 下载oh-my-zsh直接用git从github下载1git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh 替换zshrc1cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc","tags":[{"name":"zsh","slug":"zsh","permalink":"http://fangli.me/tags/zsh/"},{"name":"终端","slug":"终端","permalink":"http://fangli.me/tags/终端/"}]},{"title":"UIImage方向问题","date":"2016-09-18T02:04:07.000Z","path":"2016/09/18/UIImage方向问题/","text":"H5调用iOS客户端拍照之后上传照片到服务器，在拍照之后的预览是正常的，但是上传之后看webView里面的照片的方向不对，在UIImage里面有看到一个UIImageOrientation属性 取值为以下枚举 12345678910typedef NS_ENUM(NSInteger, UIImageOrientation) &#123; UIImageOrientationUp, // default orientation UIImageOrientationDown, // 180 deg rotation UIImageOrientationLeft, // 90 deg CCW UIImageOrientationRight, // 90 deg CW UIImageOrientationUpMirrored, // as above but image mirrored along other axis. horizontal flip UIImageOrientationDownMirrored, // horizontal flip UIImageOrientationLeftMirrored, // vertical flip UIImageOrientationRightMirrored, // vertical flip&#125;; 通过测试，iPhone拍照之后的照片的UIImageOrientation属性与拍照时手机的朝向有关，因为iPhone展示图片时会根据这个属性将照片旋转到正确的位置，但是上传到服务器之后并不会根据这个属性的值进行旋转。因此在上传服务器之前应该将照片摆正，即把UIImageOrientation属性改为UIImageOrientationUp。 拍照时home键在右边，拍出来的照片的UIImageOrientation属性为UIImageOrientationUp home键在左边，拍出来的照片的UIImageOrientation属性为UIImageOrientationDown home键在下边，拍出来的照片的UIImageOrientation属性为UIImageOrientationRight home键在上边，拍出来的照片的UIImageOrientation属性为UIImageOrientationLeft 通过给UIImage加个方法将传进来的图片摆正12345678910+ (UIImage *)orientationUpImage: (UIImage *) image&#123; if (image.imageOrientation == UIImageOrientationUp) return image; UIGraphicsBeginImageContextWithOptions(image.size, NO, image.scale); [image drawInRect:CGRectMake(0, 0, image.size.width, image.size.height)]; UIImage *normalizedImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return normalizedImage;&#125; 因为在iOS中会自动把图片显示正确，因此用重新画一张图片，结果得到的图片就是摆正的图片。","tags":[{"name":"UIImage","slug":"UIImage","permalink":"http://fangli.me/tags/UIImage/"}]},{"title":"本地同时保存多组ssh密钥以及密钥的生成","date":"2016-09-17T15:08:29.000Z","path":"2016/09/17/本地同时保存多组ssh密钥以及密钥的生成/","text":"不同网站的ssh密钥一般都是不同的, 如果不把这些密钥进行管理则会比较混乱, 可以通过配置文件的方式指定使用对应的密钥 下面是我本机.ssh目录的结构 生成密钥的时候, 尽量不要采用默认的名字和路径, 生成方法如下 12$ ssh-keygen -t rsa -C &quot;邮箱&quot; //这个是最基础的，生成默认的密钥对的名字就是id_rsa &amp; id_rsa.pub$ ssh-keygen -t rsa -C &quot;邮箱&quot; -f ~/.ssh/xxxx/xxxx //这个是指定生成的密钥对的文件名和位置，尽量采用这种 ~/.ssh目录建立一个文件config 1$ touch ~/.ssh/config 编辑config, 按照下图的方式, 自行修改为自己的实际情况即可, 通过匹配URL, 选择使用不同的密钥","tags":[{"name":"ssh","slug":"ssh","permalink":"http://fangli.me/tags/ssh/"}]},{"title":"MySQL配置远程访问","date":"2015-11-01T09:16:56.000Z","path":"2015/11/01/MySQL配置远程访问/","text":"默认安装的MySQL只允许本地连接(localhost 或 127.0.0.1)，因此如果需要远程操作数据库，例如用数据库工具操作数据库的时候就应该授权。 授权有几种方法，把下面password换成自己的密码, 0.0.0.0换成自己的IP 允许root用户在任何IP进行远程登录，并具有所有库的所有操作权限: ALL PRIVILEGES ON *.* TO 'root'@'%'IDENTIFIED BY 'password' WITH GRANT OPTION;```1234 * 允许root用户在一个特定的IP进行远程登录，并具有所有库的所有操作权限: ```GRANT ALL PRIVILEGES ON *.* TO root@&quot;0.0.0.0&quot; IDENTIFIED BY &quot;password&quot; WITH GRANT OPTION; 允许root用户在一个特定的IP进行远程登录，并具有所有库的特定操作权限: select，insert，update，delete ON *.* TO root@\"0.0.0.0\" IDENTIFIED BY \"password\";```123 最后刷新一下: ```flush privileges; 另外，在Ubuntu下还要修改一下配置文件/etc/mysql/my.cnf，找到bind-address = 127.0.0.1注释掉。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://fangli.me/tags/MySQL/"}]}]